machine ( MachineType:SquireCache, "eFPGA-side Squire Cache" )
  : Sequencer         * sequencer;
    CacheMemory       * cache;
    MessageBuffer     * mandatoryQueue;
    MessageBuffer     * requestToProxy,    network="To";
    MessageBuffer     * responseFromProxy, network="From";

    // -- parameters --
    Cycles  latency := 1;   // time to send request to Proxy
{
  // ========================================================================
  // -- States --------------------------------------------------------------
  // ========================================================================
  state_declaration ( State, desc="Cache States", default="SquireCache_State_I" )
  {
    // Base States
    I,  AccessPermission:Invalid,     desc="Unused entry";
    V,  AccessPermission:Read_Write,  desc="Valid, clean cacheline";

    // Transient States
    //  -- IV: Squire Cache uses allocation-on-fill, so there's not IV state.
  }

  // ========================================================================
  // -- Events --------------------------------------------------------------
  // ========================================================================
  enumeration ( Event, desc="Cache events" )
  {
    // From the Knight (eFPGA)
    Ld,         desc="Load from the Knight";
    St,         desc="Store from the Knight";
    LdHitTBE,   desc="Load hit in TBE";
    LdStallTBE, desc="Load hit int and stalled by TBE";

    // From the Proxy
    LdAck,      desc="Load ack from the Proxy";
    LdInv,      desc="Load ack from the Proxy, with invalidation";
    StAck,      desc="Store ack from the Proxy";
    Inv,        desc="Invalidation from the Proxy";

    // StInv,      desc="Store ack with invalidation from the Proxy"; 
  }

  // ========================================================================
  // -- Structures ----------------------------------------------------------
  // ========================================================================
  // -- Cache Entry --
  structure ( Entry, desc="Cache entry", interface="AbstractCacheEntry" )
  {
    State       state,  desc="Cache state";
    DataBlock   data,   desc="Data in the block";
  }

  // -- TBE Table --
  structure ( TBE, desc="Transaction Buffer Entry" )
  {
    Addr        addr,                     desc="Physical address of the cache line";
    DataBlock   data,                     desc="Buffered write data";
    WriteMask   mask,                     desc="Byte mask of buffered write";
    bool pendingLd,     default="false",  desc="Is there a pending load?";
    int  numPendingSts, default="0",      desc="Number of un-acked write-thrus";
  }

  structure ( TBETable, external="yes" )
  {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
  }

  TBETable TBEs, template="<SquireCache_TBE>", constructor="m_number_of_TBEs";

  // ========================================================================
  // -- Inherited Methods from AbstractController ---------------------------
  // ========================================================================
  Tick clockEdge ();
  Cycles ticksToCycles(Tick t);
  void set_cache_entry (AbstractCacheEntry b);
  void unset_cache_entry();
  void set_tbe (TBE b);
  void unset_tbe ();
  void wakeUpAllBuffers (Addr a);
  void profileMsgDelay(int virtualNetworkType, Cycles c);

  // ========================================================================
  // -- Methods -------------------------------------------------------------
  // ========================================================================
  Entry getCacheEntry (Addr addr), return_by_pointer="yes" {
    return static_cast (Entry, "pointer", cache.lookup (addr));
  }

  State getState (TBE tbe, Entry cache_entry, Addr addr) {
    if (is_valid (cache_entry)) {
      return cache_entry.state;
    } else {
      return State:I;
    }
  }

  void setState (TBE tbe, Entry cache_entry, Addr addr, State state) {
    if (is_valid (cache_entry)) {
      cache_entry.state := state;
    }
  }

  AccessPermission getAccessPermission (Addr addr) {
    Entry entry := getCacheEntry (addr);
    if (is_valid (entry)) {
      return SquireCache_State_to_permission (entry.state);
    } else {
      return AccessPermission:NotPresent;
    }
  }

  void setAccessPermission (Entry cache_entry, Addr addr, State state) {
    if (is_valid (cache_entry)) {
      cache_entry.changePermission (SquireCache_State_to_permission (state));
    }
  }

  void functionalRead (Addr addr, Packet * pkt) {
    error ( "Functional read unimpl for Squire Cache." );
  }

  int functionalWrite (Addr addr, Packet * pkt) {
    error ( "Functional write unimpl for Squire Cache." );
  }

  bool missInTBE (int offset, int size, TBE tbe) {
    if ( is_invalid (tbe) ) {
      return true;
    } else if ( tbe.pendingLd ) {
      return false;
    } else if ( tbe.numPendingSts > 0
                && tbe.mask.firstBitSet (true, offset) < offset + size
      )
    {
      return false;
    } else {
      return true;
    }
  }

  bool hitInTBE (int offset, int size, TBE tbe) {
    // make sure missInTBE -> false before calling this
    return !tbe.pendingLd && tbe.mask.count (offset) >= size;
  }

  // ========================================================================
  // -- Out Ports -----------------------------------------------------------
  // ========================================================================
  out_port ( request_out, SquireMsg, requestToProxy );

  // ========================================================================
  // -- In Ports ------------------------------------------------------------
  // ========================================================================
  // -- Response from Proxy --
  in_port ( response_in, ProxyMsg, responseFromProxy ) {
    if (response_in.isReady (clockEdge ())) {
      peek (response_in, ProxyMsg, block_on="addr") {

        Entry entry := getCacheEntry (in_msg.addr);
        TBE   tbe   := TBEs [in_msg.addr];

        if (in_msg.type == ProxyMsgType:INV) {
          trigger (Event:Inv, in_msg.addr, entry, tbe);
        } else {
          assert (is_valid (tbe));

          if (in_msg.type == ProxyMsgType:DATA) {
            assert (tbe.pendingLd);
            assert (is_invalid (entry));
            trigger (Event:LdAck, in_msg.addr, entry, tbe);
          } else if (in_msg.type == ProxyMsgType:DATA_INV) {
            assert (tbe.pendingLd);
            assert (is_invalid (entry));
            trigger (Event:LdInv, in_msg.addr, entry, tbe);
          } else if (in_msg.type == ProxyMsgType:WT_ACK) {
            assert (tbe.numPendingSts > 0);
            trigger (Event:StAck, in_msg.addr, entry, tbe);
          // } else if (in_msg.type == ProxyMsgType:WT_INV) {
          //   assert (tbe.numPendingSts > 0);
          //   trigger (Event:StInv, in_msg.addr, entry, tbe);
          } else {
            error ("Invalid ProxyMsgType");
          }
        }

      }
    }
  }

  // -- Request from Sequencer --
  in_port ( request_in, RubyRequest, mandatoryQueue ) {
    if (request_in.isReady (clockEdge ())) {
      peek (request_in, RubyRequest, block_on="LineAddress") {
        Entry entry := getCacheEntry (in_msg.LineAddress);
        TBE   tbe   := TBEs [in_msg.LineAddress];

        if (in_msg.Type == RubyRequestType:LD) {
          // check if the TBE has up-to-date write data
          int offset := getOffset (in_msg.PhysicalAddress);
          if (missInTBE ( offset, in_msg.Size, tbe )) {
            // handle it in the cache entry
            trigger (Event:Ld, in_msg.LineAddress, entry, tbe);
          } else if (hitInTBE ( offset, in_msg.Size, tbe )) {
            trigger (Event:LdHitTBE, in_msg.LineAddress, entry, tbe);
          } else {
            trigger (Event:LdStallTBE, in_msg.LineAddress, entry, tbe);
          }
        } else if (in_msg.Type == RubyRequestType:ST) {
          trigger (Event:St, in_msg.LineAddress, entry, tbe);
        } else {
          error ("Invalid RubyRequestType");
        }
      }
    }
  }

  // ========================================================================
  // -- Actions --------------------------------------------------------------
  // ========================================================================
  action ( ta_TBEAlloc, "ta", desc="Allocate TBE" ) {
    if (is_invalid (tbe)) {
      check_allocate (TBEs);
      TBEs.allocate (address);
      set_tbe (TBEs [address]);
    }
  }

  action ( tl_TBEFillLd, "tl", desc="Fill pending load in TBE" ) {
    assert (is_valid (tbe));
    assert (tbe.pendingLd);

    tbe.pendingLd := false;
    if (tbe.numPendingSts == 0) {
      TBEs.deallocate (address);
      unset_tbe ();
    }
  }

  action ( ts_TBEDecrSt, "ts", desc="Decrement number of pending stores in TBE") {
    assert (is_valid (tbe));
    assert (tbe.numPendingSts > 0);

    if (tbe.numPendingSts == 1) {
      TBEs.deallocate (address);
      unset_tbe ();
    } else {
      tbe.numPendingSts := tbe.numPendingSts - 1;
    }
  }

  action ( sr_sendLdReq, "sr", desc="Send load request to Proxy" ) {
    assert (is_valid (tbe) && !tbe.pendingLd);
    tbe.pendingLd := true;

    peek (request_in, RubyRequest) {
      enqueue (request_out, SquireMsg, latency) {
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.type        := SquireMsgType:RD;
        out_msg.addr        := address;
      }
    }
  }

  action ( wt_writeThru, "wt", desc="Write through to Proxy" ) {
    assert (is_valid (tbe));

    peek (request_in, RubyRequest) {
      tbe.numPendingSts := tbe.numPendingSts + 1;
      tbe.data.copyPartial (in_msg.WTData, in_msg.writeMask);
      tbe.mask.orMask (in_msg.writeMask);

      enqueue (request_out, SquireMsg, latency) {
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.type        := SquireMsgType:WT;
        out_msg.addr        := address;
        out_msg.data        := in_msg.WTData;
        out_msg.mask        := in_msg.writeMask;
      }

      DataBlock data := in_msg.WTData;
      sequencer.writeCallback (address, data);  // immediate ACK
    }
  }
  
  action ( pm_profMiss, "pm", desc="Profile cache miss" ) {
    cache.profileDemandMiss ();
  }

  action ( ph_profHit, "ph", desc="Profile cache hit" ) {
    cache.profileDemandHit ();
  }

  action ( lh_ldHit, "lh", desc="Load hit in cache" ) {
    assert (is_valid (cache_entry));
    cache.setMRU (cache_entry);
    sequencer.readCallback (address, cache_entry.data);
  }

  action ( lf_ldFill, "lf", desc="Load miss filled" ) {
    assert (is_valid (cache_entry));
    cache.setMRU (cache_entry);
    sequencer.readCallback (address, cache_entry.data, true);
  }

  action ( lt_ldHitTBE, "lt", desc="Load hit in TBE" ) {
    assert (is_valid (tbe));
    sequencer.readCallback (address, tbe.data);
  }

  action ( ls_ldFillStaled, "ls", desc="Load miss filled with stale data" ) {
    peek ( response_in, ProxyMsg ) {
      DataBlock data := in_msg.data;
      sequencer.readCallback (address, data, true);
    }
  }

  action ( dm_deqMandatory, "dm", desc="Dequeue from mandatory queue" ) {
    request_in.dequeue (clockEdge ());
  }

  action ( dr_deqResponse, "dr", desc="Dequeue from response queue" ) {
    Tick delay := response_in.dequeue (clockEdge ());
    profileMsgDelay (0, ticksToCycles (delay));
  }

  action ( au_allocAndUpdateCacheEntry, "au", desc="Allocate and update cache entry" ) {
    assert (is_invalid (cache_entry));

    if ( !cache.cacheAvail (address) ) {
      Addr victim := cache.cacheProbe (address);
      cache.deallocate (victim);    // silent eviction
    }

    set_cache_entry (cache.allocate (address, new Entry));

    peek (response_in, ProxyMsg) {
      cache_entry.data := in_msg.data;
    }
  }

  action ( ue_updateCacheEntry, "ue", desc="Apply store to cache entry" ) {
    assert (is_valid (cache_entry));

    peek (request_in, RubyRequest) {
      cache.setMRU (cache_entry);
      cache_entry.data.copyPartial (in_msg.WTData, in_msg.writeMask);
    }
  }

  action ( wd_wakeUpDependents, "wd", desc="Wake up stalling queues" ) {
    wakeUpAllBuffers (address);
  }

  action ( z_stallAndWaitMandatoryQueue, "z", desc="stall") {
    stall_and_wait ( request_in, address );
  }

  action ( de_deallocCacheEntry, "de", desc="Deallocate cache entry" ) {
    assert (is_valid (cache_entry));
    cache.deallocate (address);
    unset_cache_entry ();
  }

  // ========================================================================
  // -- Transitions ---------------------------------------------------------
  // ========================================================================
  transition (I, Ld) {
    ta_TBEAlloc;
    sr_sendLdReq;
    pm_profMiss;
    dm_deqMandatory;
  }

  transition (V, Ld) {
    lh_ldHit;
    ph_profHit;
    dm_deqMandatory;
  }

  transition (I, St) {
    ta_TBEAlloc;
    wt_writeThru;
    pm_profMiss;
    dm_deqMandatory;
  }

  transition (V, St) {
    ta_TBEAlloc;
    wt_writeThru;
    ue_updateCacheEntry;
    ph_profHit;
    dm_deqMandatory;
  }

  transition ({I, V}, LdHitTBE) {
    lt_ldHitTBE;
    ph_profHit;
    dm_deqMandatory;
  }

  transition ({I, V}, LdStallTBE) {
    pm_profMiss;
    z_stallAndWaitMandatoryQueue;
  }

  transition (I, LdAck, V) {
    au_allocAndUpdateCacheEntry;
    lf_ldFill;
    tl_TBEFillLd;
    dr_deqResponse;
    wd_wakeUpDependents;
  }

  transition (I, LdInv) {
    ls_ldFillStaled;
    tl_TBEFillLd;
    dr_deqResponse;
    wd_wakeUpDependents;
  }

  transition ({I, V}, StAck) {
    ts_TBEDecrSt;
    dr_deqResponse;
    wd_wakeUpDependents;
  }

  transition (V, Inv, I) {
    de_deallocCacheEntry;
    dr_deqResponse;
  }

  transition (I, Inv) {
    dr_deqResponse;
  }
}
